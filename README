Nginx HTTP push module - Turn nginx into a long-polling message queuing 
HTTP push server.

If you want a long-polling server but don't want to wait on idle connections 
via upstream proxies or make your applications totally asynchronous, use 
this module to have nginx accept and hold long-polling client connections. 
Send responses to those clients by sending an HTTP request to a different 
location.

---------------- Configuration directives & variables ------------------------
directives:
push_publisher
  default: none
  context: server, location
  Defines a server or location as the publisher. Requests from a publisher will be 
  treated as messages to send to subscribers.See protocol documentation 
  for more info. 

push_subscriber
  default: none
  context: server, location
  Defines a server or location as a subscriber. Requests from a subscriber will 
  not be responded to until a message for the subscriber (identified by 
  $push_channel_id) becomes available. See protocol documentation for more 
  info.

push_subscriber_concurrency [ last | first | broadcast ]
  default: last
  context: http, server, location
  Controls how multiple subscriber requests to the same channel id are handled. 
  The values work as follows:
   broadcast: any number of subscriber requests may be long-polling.
   last: only the most recent subscriber request is kept, all others get a 409 
     Conflict response.
   first: only the oldest subscriber request is kept, all others get a 409 
     Conflict response.

push_max_reserved_memory [ size ]
  default: 12M
  context: http
  The size of the memory chunk this module will use for all message queuing
  and buffering. 

push_min_message_buffer_length [ number ]
  default: 5
  context: http, server, location
  The minimum number of messages to store per channel. A channel's message
  buffer, will cointain at least this many most recent messages.

push_max_message_buffer_length [ number ]
  default: 50
  context: http, server, location
  The maximum number of messages to store per channel. A channel's message
  buffer, will cointain at last this many most recent messages.

push_min_message_recipients [ number ]
  default: 0
  context: http, server, location
  How many times a message must be received before it is considered for 
  deletion. Useful to guarantee message delivery.

push_message_timeout [ time ]
  default: 1h
  context: http, server, location
  How long a message may be queued before it is considered expired. If you do 
  not want messages to expire, set this to 0. Applicable only if a push_publisher 
  is present in this or a child context. 
  
push_authorized_channels_only [ on | off ]
  default: off
  context: http, server, location
  Whether or not a subscriber may create a channel. If set to on, a publisher must
  senda request to some channel (POST or PUT) before a subscriber. Otherwise, 
  all subscriber requests will get a 403 Forbidden response.
  
push_store_messages [ on | off ]
  default: on
  context: http, server, location
  Whether or not message queuing is enabled. "Off" is equivalent to the setting
  push_channel_buffer_length 0;
  
push_queue_messages [ on | off ] (DEPRECATED)
  default: on
  context: http, server, location
  see push_store_messages

push_buffer_size [ size ] (DEPRECATED)
  default: 3M
  context: http
  see push_max_reserved_memory
  
Variables:
$push_channel_id
  A token uniquely identifying a channel. Must be present in the context of 
  the push_subscriber and push_publisher directives.
  Example:
    set $push_channel_id $arg_id; #channel id is now the url parameter "id"

--------------------------- Example Config -----------------------------------
http {
  #maximum amount of memory the push module is allowed to use 
  #for buffering and stuff
  push_max_reserved_memory	12M; #default is 3M

  server {
    #publisher
    location /send {
      set $push_channel_id $arg_id; #/?id=239aff3 or somesuch
      push_publisher;
      push_message_timeout 2h; #buffered messages expire after 2 hours
      push_max_message_buffer_length 10; #store 10 messages.
    }

    #receiver
    location /listen {
      push_subscriber;
      push_subscriber_concurrency broadcast;
      set $push_channel_id $arg_id; #/?id=239aff3 or somesuch
      default_type  text/plain;
      
    }
  }
}

---------------------------- Operation ---------------------------------------
Assuming the example config given above:
Clients will connect to http://example.com/listen?id=... and have the 
response delayed until a message is POSTed to http://example.com/send?id=...
Messages can be sent to clients that have not yet connected, i.e. they are 
queued.

Upon sending a request to a push_publisher location, the server will respond with 
a 201 Created if the message has been sent. If it must be queued up (i.e. the 
push_subscriber with this id is presently connected), a 202 Accepted will be sent.
 
If you indend to have the push_publisher be a server-side application, 
it's a damn good idea to make sure the push_server location is not visible
publically, as it is intended for use only by your application.

Traversal through the message buffer by a subscriber requires proper caching
support. Make sure your client correctly sends Last-Modified and ETag headers.

----------------------- Protocol spec --------------------------------------
see the file protocol.txt

---------------------------- todo --------------------------------------------
- Add other mechanisms of server pushing. The list should include
  "long-poll" (default), "interval-poll".
- When POSTing to a publisher location, if Content-Type is "message/http", the 
  response sent to $push_channel_id should be created from the body of the 
  request.

